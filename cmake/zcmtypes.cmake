# Macros for automatically compiling ZCM types into C, Java, and Python
# libraries.
#
# The primary macro is:
#     zcmtypes_build(TYPES type1.zcm [type2.zcm ...])
#
# It expects that the directory ${PROJECT_SOURCE_DIR}/zcmtypes contains all
# the ZCM types used by the system.  The macro generates C, Java, and Python
# bindings.  See the C, Java, and Python sections below for information on
# language specific options and generated results.
#
# After invoking this macro, the following variables will be set:
#
#   ZCMTYPES_LIBS
#   ZCMTYPES_JAR
#
#
# C
# ==
#
# C bindings will be placed in ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/c.
#
# The autogenerated C bindings also get compiled to a static and shared
# library.  The library prefix will be stored in ZCMTYPES_LIBS on output.
# This prefix can be manually set using the C_LIBNAME option.
#
# C++
# ==
#
# C++ bindings will be placed in ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/cpp.
#
# The autogenerated CPP bindings are header only, so no library is created.
#
# Java
# ====
#
# If Java is available, then Java bindings are be generated and placed in
#    ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/java
#
# Additionally, targets are added to automatically compile the .java files to a
# .jar file. The location of this jar file is stored in ZCMTYPES_JAR
#
# and the .jar file will be installed to
#   ${CMAKE_INSTALL_PREFIX}/share/java
#
#
# Python
# ======
#
# If Python is enabled, then python bindings will be generated and placed in
#    ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/python
#
# Additionally, the .py files will be installed to
#   ${CMAKE_INSTALL_PREFIX}/lib/python{X.Y}/dist-packages
#
# where {X.Y} refers to the python version used to build the .py files.
#
# ----

cmake_minimum_required(VERSION 2.6.0)

# Policy settings to prevent warnings on 2.6 but ensure proper operation on
# 2.4.
if(COMMAND cmake_policy)
    # Logical target names must be globally unique.
    cmake_policy(SET CMP0002 OLD)
    # Libraries linked via full path no longer produce linker search paths.
    cmake_policy(SET CMP0003 OLD)
    # Preprocessor definition values are now escaped automatically.
    cmake_policy(SET CMP0005 OLD)
    if(POLICY CMP0011)
        # Included scripts do automatic cmake_policy PUSH and POP.
        cmake_policy(SET CMP0011 OLD)
    endif(POLICY CMP0011)
endif()

function(zcmgen)
    execute_process(COMMAND ${ZCM_GEN_EXECUTABLE} ${ARGV} RESULT_VARIABLE zcmgen_result)
    if(NOT zcmgen_result EQUAL 0)
        message(FATAL_ERROR "zcm-gen failed")
    endif()
endfunction()

function(zcmtypes_add_clean_dir clean_dir)
    get_directory_property(acfiles ADDITIONAL_MAKE_CLEAN_FILES)
    list(APPEND acfiles ${clean_dir})
    set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${acfiles}")
endfunction()

function(zcmtypes_build_c)
    set(_zcmtypes ${ARGV})

    # set some defaults

    # library name
    set(libname "${PROJECT_NAME}_zcmtypes")

    # allow defaults to be overriden by function parameters
    set(modewords C_LIBNAME)
    set(curmode "")
    foreach(word ${ARGV})
        list(FIND modewords ${word} mode_index)
        if(${mode_index} GREATER -1)
            set(curmode ${word})
        elseif(curmode STREQUAL C_LIBNAME)
            set(libname "${word}")
            set(curmode "")
        endif()
    endforeach()

    # generate C bindings for ZCM types
    set(_zcmtypes_c_dir ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/c/zcmtypes)

    # blow away any existing auto-generated files.
    file(REMOVE_RECURSE ${_zcmtypes_c_dir})

    # run zcm-gen now
    execute_process(COMMAND mkdir -p ${_zcmtypes_c_dir})
    set(zcmgen_c_flags --lazy -c --c-cpath ${_zcmtypes_c_dir} --c-hpath ${_zcmtypes_c_dir} --c-include zcmtypes ${_zcmtypes})
    zcmgen(${zcmgen_c_flags})

    # get a list of all generated .c and .h files
    file(GLOB _zcmtypes_c_files ${_zcmtypes_c_dir}/procman_zcm/*.c)
    file(GLOB _zcmtypes_h_files ${_zcmtypes_c_dir}/procman_zcm/*.h)

    # run zcm-gen at compile time
    add_custom_command(OUTPUT ${_zcmtypes_c_files} ${_zcmtypes_h_files}
        COMMAND sh -c '[ -d ${_zcmtypes_c_dir} ] || mkdir -p ${_zcmtypes_c_dir}'
        COMMAND sh -c '${ZCM_GEN_EXECUTABLE} ${zcmgen_c_flags}'
        DEPENDS ${_zcmtypes})

    # aggregate into a static library
    add_library(${libname} STATIC ${_zcmtypes_c_files})
    set_target_properties(${libname} PROPERTIES PREFIX "lib")
    set_target_properties(${libname} PROPERTIES CLEAN_DIRECT_OUTPUT 1)
    target_compile_options(${libname} PRIVATE -fPIC)
    target_include_directories(${libname} PUBLIC ${ZCM_INCLUDE_DIRS} ${zcmtypes_include_build_path})

    # Copy the .h files into the output include/ path
    set(_output_h_files)
    foreach(_zcmtype_h_file ${_zcmtypes_h_files})
      file(RELATIVE_PATH _h_relname ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/c/zcmtypes ${_zcmtype_h_file})
      set(_h_file_output ${zcmtypes_include_build_path}/zcmtypes/${_h_relname})
      add_custom_command(OUTPUT ${_h_file_output}
                         COMMAND ${CMAKE_COMMAND} -E copy ${_zcmtype_h_file} ${_h_file_output}
                         DEPENDS ${_zcmtype_h_file})
      list(APPEND _output_h_files ${_h_file_output})
    endforeach()
    add_custom_target(${PROJECT_NAME}_zcmgen_output_h_files ALL DEPENDS ${_output_h_files})
    add_dependencies(${libname} ${PROJECT_NAME}_zcmgen_output_h_files)

    #    add_library("${libname}-static" STATIC ${_zcmtypes_c_files})
    #    set_source_files_properties(${_zcmtypes_c_files} PROPERTIES COMPILE_FLAGS "-I${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/c")
    #    set_target_properties("${libname}-static" PROPERTIES OUTPUT_NAME "${libname}")
    #    set_target_properties("${libname}-static" PROPERTIES PREFIX "lib")
    #    set_target_properties("${libname}-static" PROPERTIES CLEAN_DIRECT_OUTPUT 1)

    # make header files and libraries public
    #    pods_install_libraries(${libname})
    #    pods_install_headers(${_zcmtypes_h_files} DESTINATION zcmtypes)

    # set some compilation variables
    set(ZCMTYPES_LIBS ${libname} PARENT_SCOPE)

    # create a pkg-config file
    #  	pods_install_pkg_config_file(${libname}
    #    	CFLAGS
    #    	DESCRIPTION "ZCM types for ${PROJECT_NAME}"
    #        LIBS -l${libname}
    #    	REQUIRES zcm
    #    	VERSION 0.0.0)

    zcmtypes_add_clean_dir("${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/c")
endfunction()

function(zcmtypes_build_cpp)
    set(_zcmtypes ${ARGV})

    # set some defaults

    # generate CPP bindings for ZCM types
    set(_zcmtypes_cpp_dir ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/cpp/zcmtypes)

    # blow away any existing auto-generated files.
    file(REMOVE_RECURSE ${_zcmtypes_cpp_dir})

    # run zcm-gen now
    execute_process(COMMAND mkdir -p ${_zcmtypes_cpp_dir})
    set(zcmgen_cpp_flags --lazy
                         --cpp
                         --cpp-hpath ${_zcmtypes_cpp_dir}
                         --cpp-include zcmtypes
                         ${_zcmtypes})
    zcmgen(${zcmgen_cpp_flags})

    # get a list of all generated .hpp files
    file(GLOB_RECURSE _zcmtypes_hpp_files  ${_zcmtypes_cpp_dir}/*.hpp)

    # run zcm-gen at compile time
    add_custom_command(OUTPUT ${_zcmtypes_hpp_files}
        COMMAND sh -c '[ -d ${_zcmtypes_cpp_dir} ] || mkdir -p ${_zcmtypes_cpp_dir}'
        COMMAND sh -c '${ZCM_GEN_EXECUTABLE} ${zcmgen_cpp_flags}'
        DEPENDS ${_zcmtypes})
    add_custom_target(${PROJECT_NAME}_zcmgen_cpp ALL DEPENDS ${_zcmtypes_hpp_files})

    # Copy the .hpp files into the output include/ path
    set(_output_hpp_files)
    foreach(_zcmtype_hpp_file ${_zcmtypes_hpp_files})
      file(RELATIVE_PATH _hpp_relname ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/cpp/zcmtypes ${_zcmtype_hpp_file})
      set(_hpp_file_output ${zcmtypes_include_build_path}/zcmtypes/${_hpp_relname})
      add_custom_command(OUTPUT ${_hpp_file_output}
                         COMMAND ${CMAKE_COMMAND} -E copy ${_zcmtype_hpp_file} ${_hpp_file_output}
                         DEPENDS ${_zcmtype_hpp_file})
      list(APPEND _output_hpp_files ${_hpp_file_output})
    endforeach()
    add_custom_target(${PROJECT_NAME}_zcmgen_output_hpp_files ALL DEPENDS ${_output_hpp_files})

    zcmtypes_add_clean_dir("${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/cpp")
endfunction()

function(zcmtypes_build_java)
    set(_zcmtypes ${ARGV})

    # do we have Java?
    find_package(Java)
    if(JAVA_COMPILE STREQUAL JAVA_COMPILE-NOTFOUND OR
       JAVA_ARCHIVE STREQUAL JAVA_ARCHIVE-NOTFOUND)
        message(STATUS "Not building Java ZCM type bindings (Can't find Java)")
        return()
    endif()

    if(NOT JAVA_OUTPUT_PATH)
      set(JAVA_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/java)
    endif()
    execute_process(COMMAND mkdir -p ${JAVA_OUTPUT_PATH})

    # do we have ZCM java bindings?  where is zcm.jar?
    execute_process(COMMAND pkg-config --variable=classpath zcm OUTPUT_VARIABLE ZCM_JAR_FILE)
    if(NOT ZCM_JAR_FILE)
        message(STATUS "Not building Java ZCM type bindings (Can't find zcm.jar)")
        return()
    endif()
    string(STRIP ${ZCM_JAR_FILE} ZCM_JAR_FILE)
    set(ZCMTYPES_JAR ${JAVA_OUTPUT_PATH}/${PROJECT_NAME}_zcmtypes.jar)

    # generate Java bindings for ZCM types
    set(_zcmtypes_java_dir ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/java)

    # blow away any existing auto-generated files?
    file(REMOVE_RECURSE ${_zcmtypes_java_dir})

    # run zcm-gen now
    execute_process(COMMAND mkdir -p ${_zcmtypes_java_dir})
    zcmgen(--lazy -j ${_zcmtypes} --jpath ${_zcmtypes_java_dir})

    # get a list of all generated .java files
    file(GLOB_RECURSE _zcmtypes_java_files ${_zcmtypes_java_dir}/*.java)

    # run zcm-gen at compile time
    add_custom_command(OUTPUT ${_zcmtypes_java_files}
        COMMAND sh -c '[ -d ${_zcmtypes_java_dir} ] || mkdir -p ${_zcmtypes_java_dir}'
        COMMAND sh -c '${ZCM_GEN_EXECUTABLE} --lazy -j ${_zcmtypes} --jpath ${_zcmtypes_java_dir}'
        DEPENDS ${_zcmtypes})

    set(java_classpath ${_zcmtypes_java_dir}:${ZCM_JAR_FILE})

    # search for zcmtypes_*.jar files in well-known places and add them to the
    # classpath
    foreach(pfx /usr /usr/local ${CMAKE_INSTALL_PREFIX})
        file(GLOB_RECURSE jarfiles ${pfx}/share/java/zcmtypes_*.jar)
        foreach(jarfile ${jarfiles})
            set(java_classpath ${java_classpath}:${jarfile})
            #            message("found ${jarfile}")
        endforeach()
    endforeach()

    # convert the list of .java filenames to a list of .class filenames
    foreach(javafile ${_zcmtypes_java_files})
        string(REPLACE .java .class __tmp_class_fname ${javafile})
        #        add_custom_command(OUTPUT ${__tmp_class_fname} COMMAND
        #            ${JAVA_COMPILE} -source 6 -cp ${_zcmtypes_java_dir}:${zcm_jar} ${javafile} VERBATIM DEPENDS ${javafile})
        list(APPEND _zcmtypes_class_files ${__tmp_class_fname})
        unset(__tmp_class_fname)
    endforeach()

    # add a rule to build the .class files from from the .java files
    add_custom_command(OUTPUT ${_zcmtypes_class_files} COMMAND
        ${JAVA_COMPILE} -cp ${java_classpath} ${_zcmtypes_java_files}
        DEPENDS ${_zcmtypes_java_files} VERBATIM)

    # add a rule to build a .jar file from the .class files
    add_custom_command(OUTPUT ${ZCMTYPES_JAR} COMMAND
        ${JAVA_ARCHIVE} cf ${ZCMTYPES_JAR} -C ${_zcmtypes_java_dir} . DEPENDS ${_zcmtypes_class_files} VERBATIM)
    add_custom_target(${PROJECT_NAME}_zcmtypes_jar ALL DEPENDS ${ZCMTYPES_JAR})

    install(FILES ${ZCMTYPES_JAR} DESTINATION share/java)
    set(ZCMTYPES_JAR ${ZCMTYPES_JAR} PARENT_SCOPE)

    zcmtypes_add_clean_dir(${_zcmtypes_java_dir})
endfunction()

function(zcmtypes_build_python)
    set(_zcmtypes ${ARGV})

    find_package(PythonInterp)
    if(NOT PYTHONINTERP_FOUND)
        message(STATUS "Not building Python ZCM type bindings (Can't find Python)")
        return()
    endif()

    if(NOT PYTHON_OUTPUT_PATH)
      set(PYTHON_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/python)
    endif()

    # Get python version
    execute_process(COMMAND
        ${PYTHON_EXECUTABLE} -c "import sys; sys.stdout.write(str(sys.version_info.major) + '.' + str(sys.version_info.minor))"
        OUTPUT_VARIABLE pyversion)

    set(_zcmtypes_python_dir ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/python)

    # purge existing files?
    file(REMOVE_RECURSE ${_zcmtypes_python_dir})

    # generate Python bindings for ZCM types
    execute_process(COMMAND mkdir -p ${_zcmtypes_python_dir})
    execute_process(COMMAND ${ZCM_GEN_EXECUTABLE} --lazy -p ${_zcmtypes} --ppath ${_zcmtypes_python_dir})

    # get a list of all generated .py files
    file(GLOB_RECURSE _zcmtypes_py_files ${_zcmtypes_python_dir}/*.py)

    # run zcm-gen at compile time
    add_custom_command(OUTPUT ${_zcmtypes_py_files}
      COMMAND sh -c '${ZCM_GEN_EXECUTABLE} --lazy -p ${_zcmtypes} --ppath ${_zcmtypes_python_dir}'
      DEPENDS ${_zcmtypes})
    add_custom_target(${PROJECT_NAME}_zcmgen_python ALL DEPENDS ${_zcmtypes_py_files})

    # Copy the .py files into the output python path, and generate install rules.
    set(_output_py_files)
    foreach(_zcmtype_py_file ${_zcmtypes_py_files})
      file(RELATIVE_PATH _py_relname ${CMAKE_CURRENT_BINARY_DIR}/zcmtypes/python ${_zcmtype_py_file})
      get_filename_component(_py_reldir ${_py_relname} DIRECTORY)
      set(_py_file_output ${PYTHON_OUTPUT_PATH}/${_py_relname})
      add_custom_command(OUTPUT ${_py_file_output}
                         COMMAND ${CMAKE_COMMAND} -E copy ${_zcmtype_py_file} ${_py_file_output}
                         DEPENDS ${_zcmtype_py_file})
      list(APPEND _output_py_files ${_py_file_output})

      install(FILES ${_zcmtype_py_file}
             DESTINATION lib/python${pyversion}/dist-packages/${_py_reldir})
    endforeach()
    add_custom_target(${PROJECT_NAME}_zcmgen_output_py_files ALL DEPENDS ${_output_py_files})

    zcmtypes_add_clean_dir(${_zcmtypes_python_dir})
endfunction()

function(zcmtypes_build)
    # Get the list of .zcm files to build
    set(zcmtypes)
    set(zcmtypes_include_build_path)
    set(modewords INCLUDE_BUILD_PATH TYPES)
    set(curmode "")
    foreach(word ${ARGV})
        list(FIND modewords ${word} mode_index)
        if(${mode_index} GREATER -1)
            set(curmode ${word})
        elseif(curmode STREQUAL INCLUDE_BUILD_PATH)
            set(zcmtypes_include_build_path ${word})
        elseif(curmode STREQUAL TYPES)
            if(EXISTS ${word})
                list(APPEND zcmtypes ${word})
            elseif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${word})
                list(APPEND zcmtypes ${CMAKE_CURRENT_SOURCE_DIR}/${word})
            else()
                message(FATAL_ERROR "Unable to find ${word}")
            endif()
        endif()
    endforeach()

    list(LENGTH zcmtypes _num_zcmtypes)
    if(_num_zcmtypes EQUAL 0)
        message("No ZCM types specified")
        return()
    endif()

    find_package(PkgConfig REQUIRED)
    pkg_check_modules(ZCM REQUIRED zcm)

    # find zcm-gen (it may be in the install path)
    find_program(ZCM_GEN_EXECUTABLE zcm-gen ${EXECUTABLE_OUTPUT_PATH} ${EXECUTABLE_INSTALL_PATH})
    if (NOT ZCM_GEN_EXECUTABLE)
    	message(FATAL_ERROR "zcm-gen not found!\n")
    	return()
    endif()

    if(NOT zcmtypes_include_build_path)
      set(zcmtypes_include_build_path ${CMAKE_CURRENT_BINARY_DIR}/include)
      execute_process(COMMAND mkdir -p ${zcmtypes_include_build_path})
    endif()

    zcmtypes_build_c(${zcmtypes})
    zcmtypes_build_cpp(${zcmtypes})

    zcmtypes_build_java(${zcmtypes})
    zcmtypes_build_python(${zcmtypes})
    install(FILES ${zcmtypes} DESTINATION share/zcmtypes)
endfunction()
